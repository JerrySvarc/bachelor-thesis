\chapter{Discussion}
\label{chap:discussion}

Every approach to software development has associated benefits and limitations.
For example, \citet{Pinho_Aguiar_Amaral_2023} identified several benefits and pitfalls associated with existing programming systems employing the Low-code programming approach.
Some of the common benefits and limitations of existing Low-code programming systems are the following:
\begin{itemize}
	\item Common Benefits:
	      \begin{itemize}
		      \item \emph{Low requirements for technical skills}
		      \item \emph{High speed/short development time}
		      \item \emph{Allows for learning concepts}
	      \end{itemize}

	\item Common Pitfalls:
	      \begin{itemize}
		      \item \emph{Interoperability issues}
		      \item \emph{Vendor lock-in}
		      \item \emph{Writing more code than intended}
	      \end{itemize}
\end{itemize}

In this chapter, we will critically evaluate our work and describe its benefits, limitations, and potential avenues for future research.
We will separate the limitations of the Data-driven Low-code approach from the limitations of our Data-driven UI programming system prototype as to
better evaluate the potential feasibility of the approach itself.

\section{Evaluation of the approach}

\subsection{Benefits of the approach}

Our work identifies several benefits of the Data-driven Low-code approach to creating client-side web applications.
Each benefit directly results from our specific design principles described in Chapter~\ref{chap:design}.
The main benefits are the following:
\begin{enumerate}
	\item \textbf{Guided UI element creation:} The Data-driven Hole-based approach allows for a guided process of creating the desired UI elements.
	      The input data inspires the created elements and their resulting structure.
	      This process relieves the cognitive load associated with creating UI elements from scratch, as the system automatically creates the right type
	      of element and places it at the correct place in the internal representation of UI elements.

	\item \textbf{Mitigates Vendor lock-in:} The issue of Vendor lock-in usually stems from a system's opaque internal representation of the created software artifacts
	      and the system not allowing the conversion of this internal representation to a more widely used representation.
	      This means the user cannot easily use a different tool to modify or extend the created software artifacts.

	      Our design mitigates this problem, as the ability to generate a textual representation of the created software artifact is a core requirement
	      for systems implementing our approach, mitigating the possibility of Vendor lock-in issues.

	\item \textbf{Mitigates Interoperability issues:}
	      Another issue our approach mitigates is the lack of interoperability with other existing systems.
	      Our system accepts input data in a widely used JSON format.
	      The programming system can then be used alongside existing systems, mainly those focused on data manipulation and retrieval.
	      An example of a programming system that could achieve a perfect synergy with systems implementing our approach is \citet{graphql}.

	      Another aspect of our approach that improves interoperability is the ability to generate a textual representation of the created program using a standard representation, which allows the use of other tools that accept the standard representation.
\end{enumerate}

The described benefits may serve as a motivation to implement new systems employing our described approach or incorporate our approach into existing systems.

\subsection{Limitations of the approach}
Even though our approach provides several previously described benefits, we also identify several potential limitations.
Some of these limitations are a direct result of our design principles described in Chapter~\ref{chap:design}, while others are
a side-effect of our definition of the core logic described in Chapter~\ref{chap:corelogic}.
The potential limitations are the following:
\begin{enumerate}
	\item \textbf{Necessity to prepare data in advance:} As defined in Chapter~\ref{chap:design}, the data-driven approach first involves providing concrete data to the system.
	      By some users, this can be seen as a potential negative, as creation of a simple page mandates creating the structured contents of it first.
	      This high upfront cost could be lowered by providing simple data templates which the user could modify according to their needs.
	\item \textbf{Rigid element structure:} The creation process described in Chapter~\ref{chap:corelogic} defines a structured way
	      of creating elements based on concrete data.
	      We also define the concept of \emph{structual referencing}, which enables us to dynamically create \emph{Holes} and efficiently combine the created UI elements with corresponding data.
	      However, this also means that we must maintain the exact structure of the created UI elements as the corresponding data.
	      This prevents us from modifying the structure of the created UI elements, resulting in a very rigid structure.

	      To mitigate this issue, we added the \emph{CustomWrapper} and \emph{CusomElement} types, which provide some ability to add new elements independent of the
	      structure of the data.
	\item \textbf{Potentially time and resource intensive:} The incremental creation process described in Chapter~\ref{chap:corelogic} involves simultaneously traversing the Abstract Syntax Trees representing the created UI elements and the input data.
	      We must visit each node of the ASTs during our travel to provide correct modification menus and previews for every created UI element.
	      This means the time to traverse the created ASTs grows linearly with the number of elements they contain.
	      This approach to updating the preview and modification menus could pose a problem when modifying large ASTs, as we perform the traversal after each update of the UI elements.
	      This means that the delay between changing a UI element and seeing the updated result could become too large.

	      This problem can be mitigated by employing a more targeted approach to re-rendering, such as re-rendering only the modified element and its children.

\end{enumerate}

\section{Evaluation of the implementation}

In Chapter~\ref{chap:implementation}, we described the implementation of our \emph{Data-driven UI} programming system.
The motivation for creating this prototype system was to show what a minimal but cleanly designed system satisfying design principles defined in Chapter~\ref{chap:design} looks like.
In this section, we evaluate the \emph{Data-driven UI} prototype and discuss its positive and negative aspects in implementing the functionality of the data-driven low-code approach.

\subsection{Positive aspects of the implementation}
During our benchmarking process described in Chapter~\ref{chap:walktrough}, we identified several positive aspects of the prototype system as follows:

\begin{enumerate}
	\item \textbf{High-speed UI element creation and modification:}
	      The development system allows for the fast creation of desired UI elements, as the elements are created based on the structure of the provided concrete data.
	      After the user creates all desired elements, the system provides a modification menu for each created UI element.
	      The menus provide the functionality to quickly change the properties of the corresponding element through mouse-based or keyboard-based operations.
	      The properties are automatically updated after each modification, allowing for a fast and interactive development loop.
	\item \textbf{Live preview:}
	      The system provides a live preview of the created elements and
	      automatically populates them with the corresponding data.
	      The preview is automatically updated after each modification, making the changes immediately visible.
	      The system also provides a sandboxed preview of the created web application.
	      This allows the user to test their implementation of custom behavior.
	\item \textbf{Code generation:}
	      The system automatically generates a textual representation of the created web application, incorporates the user-defined custom behavior,
	      and generates the necessary HTML elements.
\end{enumerate}


\subsection{Limitations of the implementation}

Limitations of the system are mainly related to the design of the user interface.
\begin{enumerate}
	\item \textbf{Creation process with deeply nested input data:}
	\item \textbf{Low-code menus:}
	\item \textbf{Limited capabilities:}
\end{enumerate}


\section{Future work}
This work serves as an intro
We identify several avenues for potential future reseach.
