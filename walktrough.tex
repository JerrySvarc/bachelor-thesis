\chapter{Benchmarks}
\label{chap:walktrough}

This chapter evaluates our \emph{InterfaceSmith} prototype system on three tasks, a simple \emph{TO-DO list} application and two tasks from the \citet{7GUIs-web}.
Our primary goal is to assess whether we can implement these tasks according to their
specifications by using only our prototype system and to determine if our approach successfully
reduces the amount of code that needs to be written,
as per the definition of low-code programming systems by \citet{Pinho_Aguiar_Amaral_2023}.

\section{Methodology}
We will evaluate our prototype system based on the following criteria:
\begin{itemize}
	\item \textbf{Successful implementation of all specified functionality:}
	      We must implement the exact functionality described by each task.
	      If we cannot implement a specific task as specified, we can reason about our system's limitations and potentially
	      identify problems with our implementation or design.

	\item \textbf{Number of lines of code written:}
	      If a referential solution exists, we will compare the number of lines of code written using our system versus the provided referential solution.
	      We will only consider \emph{physical lines of code} as defined by~\citet{Park_1992}.
	      Because our system requires concrete data before we can begin building the desired application, we will also include the Number of lines of code needed to be written for the data preparation.
	      We will also ignore all lines of code related to styling the elements and focus only on implementing the specified functionality and UI structure.
\end{itemize}

For each task, we will:
\begin{enumerate}
	\item Describe the task requirements.
	\item Outline the implementation process using the \emph{InterfaceSmith} system.
	\item Present the resulting application or describe what functionality cannot be implemented.
	\item Analyze the number of lines of code written.
\end{enumerate}

\section{TO-DO list application}
The first task is the creation of a simple TODO list application inspired by the \citet{TodoMVC} benchmark.
As our prototype system focuses mainly on exploring the data-driven UI creation and provides limited options for modifying the functionality of the application,
we will implement a subset of the functionality specified by the \citet{todo-spec}.

As we will implement a subset of the specified functionality, we will not compare the resulting number of LOC to any referential solution.

\subsection{Task requirements}
\subsubsection{UI elements}
The main UI elements of the application are:
\begin{enumerate}
	\item InputField: A text input field for descibing a new task.
	\item AddTodo: A button which creates a new task.
	\item Todo: A single element displaying a checkbox and the description of a task. The checkbox represents if the Todo is completed.
	\item Todos: List displaying the created Todo elements.
	\item CompletedNum: An element displaying the number of completed tasks.
\end{enumerate}

\subsubsection{Functionality}
The functionality we will try to implement is the following:
\begin{enumerate}
	\item The user can input text into the InputField element.
	\item When the user clicks the AddTodo and the InputField is not empty, create a new Todo element and display it in the Todos.
	\item The CompletedNum reflects how many Todo elements have their checkbox checked.
	\item After clicking the AllDone button, all Todo elements become completed.
\end{enumerate}

\subsection{Creation process}

The steps of the creation process are the following:
\begin{enumerate}
	\item \textbf{Prepare JSON data:} The creation process starts by creating JSON data based on the format specified by the task.
	      We can see the created JSON object in Figure~\ref{fig:todo-json}.
	      We model the data based on the UI elements we wish to create according to our specification.
	\item \textbf{Upload data to the system:} We upload the created JSON data to the system.

\end{enumerate}


\begin{figure}[htbp]
	\caption{JSON object created as input for the TO-DO list taks}
	\label{fig:todo-json}
	\begin{lstlisting}
{
  "InputField": "",
  "AddTodo": "Add todo",
  "Todos": [
      {
          "text": "Complete project proposal",
          "completed": false
      }
  ],
  "AllDoneButton": "All done"
}
    \end{lstlisting}
\end{figure}


\subsection{Results}
We \emph{successfully} created the desired application, its specified functionality, and UI elements.

\subsection{Analysis}
The referential 7GUIs solution~\cite{7guis-React-TypeScript-MobX/src/app/guis/counter.tsx} for the counter task consists of 11 LOCs.

We will now analyze the Number of LOCs needed to implement the Counter task using our programming system
\begin{itemize}
	\item In Step 1, we created the input data and wrote a total of 4 LOC.
	\item   In Steps 2-4, we created and modified the UI elements using only mouse-based operations, resulting in 0 LOC written.
	\item   In Step 5, we created a custom function, for which we wrote its name and implementation, resulting in 2 LOC written.
	\item   In Step 6, we added a handler to the \texttt{button} element through mouse-based operations, resulting in 0 LOC written.
\end{itemize}
We wrote \emph{six} lines of physical code in total, and the rest of the operations were performed through a mouse-based interface.



\section{Counter Task (7GUIs)}
The Counter task is defined by the \citet{7GUIs-web} as follows: ``The task is to build a frame containing a label or read-only textfield T and a button B. Initially, the value in T is “0” and each click of B increases the value in T by one.''

\subsection {Creation process}

The steps of the creation process are the following:
\begin{enumerate}
	\item \textbf{Prepare JSON data:} The creation process starts by creating JSON data based on the format specified by the task.
	      We can see the created JSON object in Figure~\ref{fig:counter-json}.
	\item \textbf{Upload data to the system:} We upload the created JSON data to the system.
	\item \textbf{Replace holes with new elements:} This step involves clicking on a provided button menu for each Hole element.
	\item \textbf{Modify the elements using the context menus:} We use the provided context menus to change the tag of each element.
	      We select the label tag for the label element and the button for the button element.
	\item \textbf{Implementation of custom behavior:} We select the \emph{Custom Handlers} menu.
	      We type the name of our custom function into the provided input field and
	      we name the function as \texttt{plusOne}.
	      Then, using JavaScript, we implement the desired behavior of increasing the value of the label field by one
	      every time this function is called.
	      Into the editor window, we input the following: \texttt{data.label++;}.
	      We do not need to write anything else, as the system automatically generates the function's body and other event handlers.
	\item \textbf{Add the "onClick" handler to the button element:} We use the menu for the \emph{button} element to add an event handler
	      which calls the \texttt{plusOne} function when triggered.
\end{enumerate}


\begin{figure}[htbp]
	\caption{JSON object created as input for the Counter task (7GUIs)}
	\label{fig:counter-json}
	\begin{lstlisting}
{
  "label": 0,
  "button": "count"
}
    \end{lstlisting}
\end{figure}

\subsection{Results}
We \emph{successfully} created the desired application, its specified functionality, and UI elements.

\subsection{Analysis}
The referential 7GUIs solution~\cite{7guis-React-TypeScript-MobX/src/app/guis/counter.tsx} for the counter task consists of 11 LOCs.

We will now analyze the Number of LOCs needed to implement the Counter task using our programming system
\begin{itemize}
	\item In Step 1, we created the input data and wrote a total of 4 LOC.
	\item   In Steps 2-4, we created and modified the UI elements using only mouse-based operations, resulting in 0 LOC written.
	\item   In Step 5, we created a custom function, for which we wrote its name and implementation, resulting in 2 LOC written.
	\item   In Step 6, we added a handler to the \texttt{button} element through mouse-based operations, resulting in 0 LOC written.
\end{itemize}
We wrote \emph{six} lines of physical code in total, and the rest of the operations were performed through a mouse-based interface.




\section{Temperature Converter Task (7GUIs)}
Temperature Converter task by the \citet{7GUIs-web} involves creating a user interface with two input fields for Celsius and Fahrenheit temperatures,
implementing bidirectional conversion between the two fields when valid numerical input is provided.

\subsection {Creation process}

The steps of the creation process are the following:
\begin{enumerate}
	\item \textbf{Prepare JSON data:} The creation process starts by creating JSON data based on the format specified by the task.
	      We can see the created JSON object in Figure~\ref{fig:temp-json}.

\end{enumerate}


\begin{figure}[htbp]
	\caption{JSON object created as input for the Counter task (7GUIs)}
	\label{fig:temp-json}
	\begin{lstlisting}
{
  "label": 0,
  "button": "count"
}
    \end{lstlisting}
\end{figure}

\subsection{Results}
We \emph{successfully} created the desired application, its specified functionality, and UI elements.

\subsection{Analysis}
The referential 7GUIs solution~\cite{7guis-React-TypeScript-MobX/src/app/guis/counter.tsx} for the counter task consists of 11 LOCs.

We will now analyze the Number of LOCs needed to implement the Counter task using our programming system
\begin{itemize}
	\item In Step 1, we created the input data and wrote a total of 4 LOC.
	\item   In Steps 2-4, we created and modified the UI elements using only mouse-based operations, resulting in 0 LOC written.
	\item   In Step 5, we created a custom function, for which we wrote its name and implementation, resulting in 2 LOC written.
	\item   In Step 6, we added a handler to the \texttt{button} element through mouse-based operations, resulting in 0 LOC written.
\end{itemize}
We wrote \emph{six} lines of physical code in total, and the rest of the operations were performed through a mouse-based interface.
\section{Evaluation}
In this section, we summarize our findings from the benchmark tasks.
Our evaluation process involved attempting to implement three distinct tasks using the \emph{Data DrUId} prototype system.


