\chapter{Implementation}
\label{chap:implementation}

In this Chapter, we describe the practical realization of the design principles described in Chapter~\ref{chap:design} and the core logic described in Chapter~\ref{chap:corelogic}.
We explore the technologies chosen, the system's architecture, and key implementation details of \emph{Data-driven UI}.


\section{Technologies}
\label{sec:technologies}
To provide context for the implementation, we'll first examine the technologies used in developing the \emph{Data-driven UI} system, as our technological choices significantly shaped the design and functionality of the resulting application.

We decided to create the \emph{Data-driven UI} editor in a from of a browser-based client-side application providing a graphical user interface, rather than a traditional desktop application.
We made this decision to allow greater cross-platform compatibility and the ability to see the preview of the created web applications in a browser-based environment.
We also wanted to implement the system using a programming language with functional programming capabilities and a strong ecosystem, which narrowed our range of suitable options.
The system is implemented using the following key technologies:
\begin{itemize}
	\item \textbf{F\#:} The \citet{fsharp} programming language is used to implement the entire application, including the core logic and the user interface, chosen for its strong type system and functional programming capabilities.
	\item \textbf{Fable:} The \citet{fable} compiler, briefly described in Section~\ref{sub:Fable}, compiles the F\# source code to JavaScript, enabling browser-based execution and using technologies from the JavaScript ecosystem.
	\item \textbf{React:} The \citet{feliz} library provides a domain-specific language (DSL) for building \emph{React} user interface components and applications in F\#.
	\item \textbf{Elmish:} \citet{elmish} is a library used to enable the creation of Elmish style applications in F\#, which follow the MVU pattern described in Section~\ref{sub:elmish}.
	\item \textbf{Tailwind:} We use the \citet{tailwind} CSS framework for the layout and styling of the UI components of the application, which provides composable CSS classes and enables high customizability of the UI.
	\item \textbf{SimpleJson:} The \citet{simpleJson} library is used to parse the input JSON data into the internal representation described in Section~\ref{sub:json}.
\end{itemize}


\subsection{Alternatives}
While we selected the technologies mentioned in the previous Section for our implementation, for several of them we considered using alternative technologies:
\begin{itemize}
	\item \textbf{Programming Language:} Instead of F\#, we could have used other functional programming languages such as Haskell or OCaml.
	      These languages also offer strong type systems and functional programming capabilities.
	      However, F\# was chosen for its seamless integration with the .NET ecosystem, high-quality development tools and documentation, and its ability to be compiled to JavaScript via Fable.

	\item \textbf{CSS Framework:} We considered using alternative CSS frameworks, such as Bulma or Bootstrap, which provide pre-made styled components.
	      We chose to use Tailwind instead, as the composable styling classes allow for a more direct approach to styling UI elements, instead of trying to adapt and modify the pre-made components.

	\item \textbf{JSON Parsing:} Instead of Fable.SimpleJson, we could have used the closest alternative library called \citet{thoth}.
	      The main strenght of this library is the ability to create custom JSON \emph{encoders} and \emph{decoders}.
	      However, as we need the ability to parse JSON data of abitrary strucuture, SimpleJson's lightweight nature and its internal representation of the parsed data made it our preffered choice.
\end{itemize}
While these alternatives have their strengths, our chosen technologies provided the best balance of functional programming capabilities, browser compatibility, and ecosystem support for our specific requirements.


\section{System architecture}
\label{sec:appArch}
Before we describe the implementation specifics, we must first describe the \emph{architecture} of the implementation.
The implementation consists of different F\# \emph{modules}, each providing different functionality.
We define two main modules named \emph{CoreLogic} and \emph{Editor}, which contain sub-modules implementing the specific functionality.
The contents of these modules can be described as follows:
\begin{enumerate}
	\item \textbf{Core logic module:} Contains modules responsible for implementing the Core logic described in Chapter~\ref{chap:corelogic}.
	\item \textbf{Editor module:} Modules focused on implementing the user interface of the programming system and its functionality.
	      They use and depend on the functionality provided by the Corelogic module.
\end{enumerate}

We can see the strucuture of the application illustrated in Figure~\ref{fig:architecture}.
We will describe the main modules in greater detail in the following Sections.

Each sub-module comprises various functions or type definitions.
In our implementation, we separate type definitions and functions into distinct modules, similarly to the separation of \emph{Domain} and \emph{Infrastructure} layers of the \emph{Domain-driven} architecture.
The modules containing the type definitions define the system's domain and have either none or a small number of external dependencies.
The modules containing the functions implement the behaviors and operations that manipulate and utilize the domain types.
This approach makes the architecture extensible, as
\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[
			node distance = 1cm and 1.5cm,
			block/.style = {rectangle, draw, fill=blue!20,
					text width=6em, text centered, rounded corners, minimum height=3em},
			line/.style = {draw, -stealth},
		]
		% Main application node
		\node [block, text width=10em] (app) {Data-driven UI Application};

		% Module types
		\node [block, below = of app] (editor) {Editor Modules};
		\node [block, left=of editor] (core) {Core Logic Modules};
		% Draw arrows
		\path [line] (app) -- (core);
		\path [line] (app) -- (editor);

	\end{tikzpicture}
	\caption{Types of Modules in the Data-driven UI Application}
	\label{fig:architecture}
\end{figure}


\section{CoreLogic module}
To implement the \emph{Data-driven UI} system, we must first define and implement the types and operations described in Chapter~\ref{chap:corelogic}.
The following sub-modules provide this functionality:
\begin{itemize}
	\item \textbf{Types.RenderingTypes:} Contains type definitions of types such as the previously described \emph{RenderingCode}, \emph{CustomWrapper}, and other related types.
	\item \textbf{Operations.RenderingCode:} Implements operations such as \emph{replace} for replacing a RenderingCode inside a RenderingCode AST and other miscellaneous operations on the RenderingCode and related types.
	\item \textbf{Operations.DataRecognition:} Implements the mapping process between the input data and the internal representation of UI elements, such as the \emph{recognizeJson} function defined in Section~\ref{sec:mapping}.
	\item \textbf{Operations.CodeGeneration:} Implements code generation functionality for creating a textual representation of a created web application in the form of an input RenderingCode AST.
\end{itemize}

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[
			node distance = 1cm and 1.2cm,
			block/.style = {rectangle, draw, fill=blue!20,
					text width=8em, text centered, rounded corners, minimum height=3em},
			line/.style = {draw, -stealth},
		]
		% Main Core Logic node
		\node [block, text width=8em] (core) {Core Logic};

		% Module types
		\node [block, left=of core] (types) {Types.\\RenderingTypes};
		\node [block, below=of types] (rendering) {Operations.\\RenderingCode};
		\node [block,  right=of rendering] (recognition) {Operations.\\DataRecognition};
		\node [block, right=of recognition] (generation) {Operations.\\CodeGeneration};

		% Draw arrows
		\path [line] (core) -- (types);
		\path [line] (core) -- (rendering);
		\path [line] (core) -- (recognition);
		\path [line] (core) -- (generation);

	\end{tikzpicture}
	\caption{ Core Logic Module Structure}

\end{figure}


\section{Editor module}
\label{sec:ui}


\subsection{}
\subsection{Utilities}


\section{Challenges and Solutions}

\section{Building and Deployment}

\section{Testing}
To test our implementation, we created a separate project named \emph{Tests}.
We implemented \emph{Unit tests} for various functions from the Core logic category of modules, such as the \emph{replace} function from the \emph{CoreLogic.Operations.RenderingCode} module, and various functions from the \emph{CoreLogic.Operations.CodeGeneration} module.

To write the tests, we use the \citet{mocha} library which provides
\section{Summary}
