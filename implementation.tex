\chapter{Implementation}
\label{chap:implementation}

In this Chapter, we describe the practical realization of the design principles described in Chapter~\ref{chap:design} and the core logic described in Chapter~\ref{chap:corelogic}.
We explore the technologies chosen, the system's architecture, and key implementation details of \emph{Data-driven UI}.


\section{Technologies}
\label{sec:technologies}
To provide context for the implementation, we'll first examine the technologies used in developing the \emph{Data-driven UI} system, as our technological choices significantly shaped the design and functionality of the resulting application.

We decided to create the \emph{Data-driven UI} editor in a from of a browser-based client-side application providing a graphical user interface, rather than a traditional desktop application.
We made this decision to allow greater cross-platform compatibility and the ability to see the preview of the created web applications in a browser-based environment.
We also wanted to implement the system using a programming language with functional programming capabilities and a strong ecosystem, which narrowed our range of suitable options.
The system is implemented using the following key technologies:
\begin{itemize}
	\item \textbf{F\#:} The \citet{fsharp} programming language is used to implement the entire application, including the core logic and the user interface, chosen for its strong type system and functional programming capabilities.
	\item \textbf{Fable:} The \citet{fable} compiler, briefly described in Section~\ref{sub:Fable}, compiles the F\# source code to JavaScript, enabling browser-based execution and using technologies from the JavaScript ecosystem.
	\item \textbf{React:} The \citet{feliz} library provides a domain-specific language (DSL) for building \emph{React} user interface components and applications in F\#.
	\item \textbf{Elmish:} \citet{elmish} is a library used to enable the creation of Elmish style applications in F\#, which follow the MVU pattern described in Section~\ref{sub:elmish}.
	\item \textbf{Tailwind:} We use the \citet{tailwind} CSS framework for the layout and styling of the UI components of the application, which provides composable CSS classes and enables high customizability of the UI elements.
	\item \textbf{SimpleJson:} The \citet{simpleJson} library is used to parse the input JSON data into the internal representation described in Section~\ref{sub:json}.
\end{itemize}


\subsection{Alternatives}
While we selected the technologies mentioned in the previous Section for our implementation, for several of them we considered using alternative technologies:
\begin{itemize}
	\item \textbf{Programming Language:} Instead of F\#, we could have used other functional programming languages such as Haskell or OCaml.
	      These languages also offer strong type systems and functional programming capabilities.
	      However, F\# was chosen for its seamless integration with the .NET ecosystem, high-quality development tools and documentation, and its ability to be compiled to JavaScript via Fable.

	\item \textbf{CSS Framework:} We considered using alternative CSS frameworks, such as Bulma or Bootstrap, which provide pre-made styled components.
	      We chose to use Tailwind instead, as the composable styling classes allow for a more direct approach to styling UI elements, instead of trying to adapt and modify the pre-made components.

	\item \textbf{JSON Parsing:} Instead of Fable.SimpleJson, we could have used the closest alternative library called \citet{thoth}.
	      The main strenght of this library is the ability to create custom JSON \emph{encoders} and \emph{decoders}.
	      However, as we need the ability to parse JSON data of abitrary strucuture, SimpleJson's lightweight nature and its internal representation of the parsed data made it our preffered choice.
\end{itemize}
While these alternatives have their strengths, our chosen technologies provided the best balance of functional programming capabilities, browser compatibility, and ecosystem support for our specific requirements.



\section{System architecture}
\label{sec:appArch}
Before we describe the implementation specifics, we must first describe the \emph{architecture} of the implementation.
The implementation consists of different F\# \emph{modules}, each providing different functionality.
We define two main modules named \emph{Core Logic} and \emph{Editor}, which contain sub-modules implementing the specific functionality.
The contents of these modules can be described as follows:
\begin{enumerate}
	\item \textbf{Core Logic module:} Contains modules responsible for implementing the Core logic described in Chapter~\ref{chap:corelogic}.
	\item \textbf{Editor module:} Modules focused on implementing the user interface of the programming system and its functionality.
	      They use and depend on the functionality provided by the CoreLogic module.
\end{enumerate}

The application's structure is illustrated in Figure~\ref{fig:architecture}.
We will describe the main modules in greater detail in the following Sections.

Each sub-module comprises various functions or type definitions.
In our implementation, we separate type definitions and functions into distinct modules, similarly to the separation of \emph{Domain} and \emph{Infrastructure} layers of the \emph{Domain-driven} architecture.
The modules containing the type definitions define the system's domain and have either none or a small number of external dependencies.
The modules containing the functions implement the behaviors and operations that manipulate and utilize the domain types.
This approach makes the application extensible.
For example, we can add new functionality to the editor sub-modules without changing the implementation of the CoreLogic sub-modules.
\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[
			node distance = 0.5cm and 0.5cm,
			mainblock/.style = {rectangle, draw, fill=gray!20,
					text width=10em, text centered, rounded corners, minimum height=4em},
			subblock/.style = {rectangle, draw, fill=blue!20,
					text width=6em, text centered, rounded corners, minimum height=3em},
			line/.style = {draw, -stealth, thick},
		]
		% Main application node
		\node [mainblock] (app) {Data-driven UI Application};

		% Module types
		\node [subblock, below left=of app] (editor) {Editor Module};
		\node [subblock, below right=of app] (core) {Core Logic Module};

		% Draw arrows
		\path [line] (app.south west) -- (editor.north);
		\path [line] (app.south east) -- (core.north);


	\end{tikzpicture}
	\caption{Two main modules implementing the Data-driven UI Application}
	\label{fig:architecture}
\end{figure}


\section{Core Logic Module}
The Core Logic module forms the foundation of our \emph{Data-driven UI} system, implementing the types and operations described in Chapter~\ref{chap:corelogic}.
Figure~\ref{fig:core-logic-structure} illustrates the overall structure of this module.
We divide the implementation into the following sub-modules:
\begin{description}
	\item[Types:] This category encompasses modules that define the fundamental data structures of our system:
	      \begin{description}
		      \item[RenderingTypes:] Contains definitions for key types such as \emph{RenderingCode}, \emph{CustomWrapper}, and other related types.
		            These types form the backbone of our UI representation system.
	      \end{description}

	\item[Operations:] This category includes modules that implement various operations on the types defined in the Types module:
	      \begin{description}
		      \item[RenderingCode:] Implements crucial operations such as the \emph{replace} function, which modifies the RenderingCode AST.
		            This module is central to manipulating our UI representation.

		      \item[DataRecognition:] Handles the mapping process between input data and our internal UI element representation.
		            It includes the \emph{recognizeJson} function, detailed in Section~\ref{sec:mapping}, which is key to our data-driven approach.

		      \item[CodeGeneration:] Provides functionality to generate textual representations of created web applications from RenderingCode ASTs.
		            This module bridges our internal representations with output code.
	      \end{description}
\end{description}


\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[
			node distance = .5cm and 0.5cm,
			mainblock/.style = {rectangle, draw, fill=gray!20,
					text width=6em, text centered, rounded corners, minimum height=3em},
			typeblock/.style = {rectangle, draw, fill=blue!20,
					text width=6em, text centered, rounded corners, minimum height=3em},
			opblock/.style = {rectangle, draw, fill=green!20,
					text width=6em, text centered, rounded corners, minimum height=3em},
			line/.style = {draw, -stealth},
		]
		% Main Core Logic node
		\node [mainblock, text width=10em] (core) {Core Logic};

		% Types
		\node [typeblock, below left=of core] (types) {Types};
		\node [typeblock, below=of types] (renderingtypes) {Rendering\\Types};

		% Operations
		\node [opblock, below right=of core] (operations) {Operations};
		\node [opblock, below left=of operations] (rendering) {Rendering\\Code};
		\node [opblock, below=of operations] (recognition) {Data\\Recognition};
		\node [opblock, below right=of operations] (generation) {Code\\Generation};

		% Draw arrows
		\path [line] (core) -- (types);
		\path [line] (core) -- (operations);
		\path [line] (types) -- (renderingtypes);
		\path [line] (operations) -- (rendering);
		\path [line] (operations) -- (recognition);
		\path [line] (operations) -- (generation);


	\end{tikzpicture}
	\caption{Core Logic Module Structure}
	\label{fig:core-logic-structure}
\end{figure}

This modular structure allows for clear separation of concerns, with types and operations distinctly categorized.
It improves the extensibility and maintainablity of the Core Logic module.

\section{Editor module}
The Editor module is the second main module of the \emph{Data-driven UI's} implementation.
It is responsible for implementing the programming system's UI and functionality.
It facilitates tools from the Core Logic module and technologies described in Section~\ref{sec:technologies} such as Elmish, to provide an interactive low-code editor environment.
We divide the implementation into the following sub-modules:
\begin{description}
	\item[Types:] This category encompasses modules that define data types and data structures used for representing the state and operations of an Elmish-style application as described in Section~\ref{sub:elmish}.
	      \begin{description}
		      \item[EditorModel:] Definitions of the domain types representing the internal state of the application.
		      \item[PageEditorModel:] Definitions of the domain types representing the internal state of a Page editor component.
	      \end{description}

	\item[Utilities:] Implements miscellanious functionality such as importing Icons, handling of file uploads, and parsing of the JSON data from its textual representation using the \citet{simpleJson} library.
	\item[Operations:]
	      \begin{description}
		      \item[CustomRendering:]
	      \end{description}

	\item[Components:]
	      \begin{description}
		      \item[EditorComponents:] Contains definitions for key types such as \emph{RenderingCode}, \emph{CustomWrapper}, and other related types.
		            These types form the backbone of our UI representation system.
		      \item[PageEditorComponents:] Contains definitions for key types such as \emph{RenderingCode}, \emph{CustomWrapper}, and other related types.
		            These types form the backbone of our UI representation system.

	      \end{description}
\end{description}



\subsection{Utilities}


\section{Challenges and Solutions}

\section{Building and Deployment}

\section{Testing}
To test our implementation, we created a separate project named \emph{Tests}.
We implemented \emph{Unit tests} for various operations from the Core Logic module, such as the \emph{replace} function from the \emph{CoreLogic.Operations.RenderingCode} module, and various functions from the \emph{CoreLogic.Operations.CodeGeneration} module.

We use the \citet{mocha} library which provides
\section{Summary}
