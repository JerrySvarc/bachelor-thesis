\chapter{Implementation}
\label{chap:implementation}

In this Chapter, we briefly describe the practical realization of the design principles described in Chapter~\ref{chap:design} and the core logic described in Chapter~\ref{chap:corelogic}.
We explore the technologies chosen, the system's architecture, and key implementation details of \emph{Data-driven UI}.


\section{Technologies}
\label{sec:technologies}
To provide context for the implementation, we'll first examine the technologies used in developing the \emph{Data-driven UI} system, as our technological choices significantly shaped the design and functionality of the resulting application.

We decided to create the \emph{Data-driven UI} editor in a from of a browser-based client-side application providing a graphical user interface, rather than a traditional desktop application.
We made this decision to allow greater cross-platform compatibility and the ability to see the preview of the created web applications in a browser-based environment.
We also wanted to implement the system using a programming language with functional programming capabilities and a strong ecosystem, which narrowed our range of suitable options.
The system is implemented using the following key technologies:
\begin{itemize}
	\item \textbf{F\#:} The \citet{fsharp} programming language is used to implement the entire application, including the core logic and the user interface, chosen for its strong type system and functional programming capabilities.
	\item \textbf{Fable:} The \citet{fable} compiler, briefly described in Section~\ref{sub:Fable}, compiles the F\# source code to JavaScript, enabling browser-based execution and using technologies from the JavaScript ecosystem.
	\item \textbf{React:} The \citet{feliz} library provides a domain-specific language (DSL) for building \emph{React} user interface components and applications in F\#.
	\item \textbf{Elmish:} \citet{elmish} is a library used to enable the creation of Elmish style applications in F\#, which follow the MVU pattern described in Section~\ref{sub:elmish}.
	\item \textbf{Tailwind:} We use the \citet{tailwind} CSS framework for the layout and styling of the UI components of the application, which provides composable CSS classes and enables high customizability of the UI elements.
	\item \textbf{SimpleJson:} The \citet{simpleJson} library is used to parse the input JSON data into the internal representation described in Section~\ref{sub:json}.
  \item \textbf{SAFE stack template:} We use the \citet{safestack} template's \emph{Build} project, which provides scripts for building web applications built in F\#. 
\end{itemize}


\subsection{Alternatives}
While we selected the technologies mentioned in the previous Section for our implementation, for several of them we considered using alternative technologies:
\begin{itemize}
	\item \textbf{Programming Language:} Instead of F\#, we could have used other functional programming languages such as Haskell or OCaml.
	      These languages also offer strong type systems and functional programming capabilities.
	      However, F\# was chosen for its seamless integration with the .NET ecosystem, high-quality development tools and documentation, and its ability to be compiled to JavaScript via Fable.

	\item \textbf{CSS Framework:} We considered using alternative CSS frameworks, such as Bulma or Bootstrap, which provide pre-made styled components.
	      We chose to use Tailwind instead, as the composable styling classes allow for a more direct approach to styling UI elements, instead of trying to adapt and modify the pre-made components.

	\item \textbf{JSON Parsing:} Instead of Fable.SimpleJson, we could have used the closest alternative library called \citet{thoth}.
	      The main strenght of this library is the ability to create custom JSON \emph{encoders} and \emph{decoders}.
	      However, as we need the ability to parse JSON data of abitrary strucuture, SimpleJson's lightweight nature and its internal representation of the parsed data made it our preffered choice.
\end{itemize}
While these alternatives have their strengths, our chosen technologies provided the best balance of functional programming capabilities, browser compatibility, and ecosystem support for our specific requirements.



\section{System architecture}
\label{sec:appArch}
Before we describe the implementation specifics, we must first describe the \emph{architecture} of the implementation.
The implementation consists of different F\# \emph{modules}, each providing different functionality.
We define two main modules named \emph{Core Logic} and \emph{Editor}, which contain sub-modules implementing the specific functionality.
The contents of these modules can be described as follows:
\begin{enumerate}
	\item \textbf{Core Logic module:} Contains modules responsible for implementing the Core logic described in Chapter~\ref{chap:corelogic}.
	\item \textbf{Editor module:} Modules focused on implementing the user interface of the programming system and its functionality following the Elmish architecture described in Section~\ref{sub:elmish}.
	      They use and depend on the functionality provided by the CoreLogic module.
\end{enumerate}
We will describe the main modules in greater detail in the following Sections.

Each sub-module comprises various functions or type definitions.
In our implementation, we separate type definitions and functions into distinct modules, similarly to the separation of \emph{Domain} and \emph{Infrastructure} layers of the \emph{Domain-driven} architecture.
The modules containing the type definitions define the system's domain and have either none or a small number of external dependencies.
The modules containing the functions implement the behaviors and operations that manipulate and utilize the domain types.
This approach makes the application extensible.
For example, we can add new functionality to the Editor without changing the implementation of the CoreLogic sub-modules.


\section{Core Logic Module}
The Core Logic module forms the foundation of our \emph{Data-driven UI} system, implementing the types and operations described in Chapter~\ref{chap:corelogic}.
Figure~\ref{fig:core-logic-structure} illustrates the overall structure of this module.
We divide the implementation into the following sub-modules:
\begin{itemize}
	\item \textbf{Types:} This module encompasses sub-modules that define the fundamental data structures of our system:
	      \begin{itemize}
		      \item \textbf{RenderingTypes:} Contains definitions for key types such as \emph{RenderingCode}, \emph{CustomWrapper}, and other related types.
		            These types form the backbone of our UI representation system.
	      \end{itemize}

	\item \textbf{Operations:} This module includes sub-modules that implement various operations on the types defined in the Types module:
	      \begin{itemize}
		      \item \textbf{RenderingCode:} Implements crucial operations such as the \emph{replace} function, which modifies the RenderingCode AST.
		            This module is central to manipulating our UI representation.

		      \item \textbf{DataRecognition:}  Handles the mapping process between input data and our internal UI element representation.
		            It includes the \emph{recognizeJson} function, detailed in Section~\ref{sec:mapping}, which is key to our data-driven approach.

		      \item\textbf{CodeGeneration:} Provides functionality to generate textual representations of created web applications from RenderingCode ASTs.
		            This module bridges our internal representations with output code.
	      \end{itemize}
\end{itemize}


\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[
			node distance = 0.5cm and 0.5cm,
			mainblock/.style = {rectangle, draw, fill=gray!20,
					text width=6em, text centered, rounded corners, minimum height=3em},
			typeblock/.style = {rectangle, draw, fill=blue!20,
					text width=6em, text centered, rounded corners, minimum height=3em},
			opblock/.style = {rectangle, draw, fill=green!20,
					text width=6em, text centered, rounded corners, minimum height=3em},
			line/.style = {draw, -stealth},
		]
		% Main Core Logic node
		\node [mainblock, text width=10em] (core) {Core Logic};

		% Types
		\node [typeblock, below left=of core] (types) {Types};
		\node [typeblock, below=of types] (renderingtypes) {Rendering\\Types};

		% Operations
		\node [opblock, below right=of core] (operations) {Operations};
		\node [opblock, below left=of operations] (rendering) {Rendering\\Code};
		\node [opblock, below=of operations] (recognition) {Data\\Recognition};
		\node [opblock, below right=of operations] (generation) {Code\\Generation};

		% Draw arrows
		\path [line] (core) -- (types);
		\path [line] (core) -- (operations);
		\path [line] (types) -- (renderingtypes);
		\path [line] (operations) -- (rendering);
		\path [line] (operations) -- (recognition);
		\path [line] (operations) -- (generation);


	\end{tikzpicture}
	\caption{Core Logic Module Structure}
	\label{fig:core-logic-structure}
\end{figure}

This modular structure allows for clear separation of concerns, with types and operations distinctly categorized.
It improves the extensibility and maintainablity of the Core Logic module.

\section{Editor module}
The Editor module is the second main module of the \emph{Data-driven UI's} implementation.
It is responsible for implementing the programming system's UI and functionality.
It facilitates tools from the Core Logic module and technologies described in Section~\ref{sec:technologies} such as Elmish, to provide an interactive low-code editor environment.
We divide the implementation into the following sub-modules:

\begin{itemize}
    \item \textbf{Types:} This module defines the core data structures that represent the state and support the operations of our Elmish-style application, as detailed in Section~\ref{sub:elmish}.
        \begin{itemize}
            \item \textbf{EditorModel:} Encapsulates the domain types that represent the comprehensive internal state of the Data-driven UI application, including user interface states and data manipulation contexts.
            \item \textbf{PageEditorModel:} Defines specialized domain types focused on representing the internal state of the Page Editor component, capturing element hierarchies and editing contexts.
        \end{itemize}

    \item \textbf{Utilities:} Provides a collection of essential helper functions that support various aspects of the application:
        \begin{itemize}
            \item Efficient icon importing and management
            \item Robust file upload handling and processing
            \item JSON data parsing and serialization, leveraging the \citet{simpleJson} library for optimal performance
        \end{itemize}

    \item \textbf{Operations:} Houses sub-modules that implement core functionalities central to the editor's capabilities:
        \begin{itemize}
            \item \textbf{CustomRendering:} Implements sophisticated algorithms for dynamically rendering previews of the RenderingCode AST, coupled with interactive modification menus that adapt to the current editing context.
        \end{itemize}

    \item \textbf{Components:} Implements a suite of custom React components that form the interactive user interface:
        \begin{itemize}
            \item \textbf{EditorComponents:} Provides a set of versatile components that deliver general editor functionality, including an advanced tab management system inspired by industry-standard editors like Visual Studio Code.
            \item \textbf{PageEditorComponents:} Offers specialized components designed for intuitive creation, real-time preview, and efficient modification of the RenderingCode AST, enabling a seamless editing experience.
        \end{itemize}
\end{itemize}

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[
        node distance = 1cm,
        mainblock/.style = {rectangle, draw, fill=gray!20,
                text width=8em, text centered, rounded corners, minimum height=3em},
        subblock/.style = {rectangle, draw, fill=blue!20,
                text width=7em, text centered, rounded corners, minimum height=2.5em},
        subsubblock/.style = {rectangle, draw, fill=green!20,
                text width=6em, text centered, rounded corners, minimum height=2em},
        line/.style = {draw, -stealth},
    ]
        % Main Editor Module node
        \node [mainblock] (editor) {Editor Module};
        
        % Main sub-modules
        \node [subblock, above=of editor] (types) {Types};
        \node [subblock, left=of editor] (utilities) {Utilities};
        \node [subblock, right=of editor] (operations) {Operations};
        \node [subblock, below=of editor] (components) {Components};
        
        % Types sub-modules
        \node [subsubblock, above left=of types] (editormodel) {Editor\\Model};
        \node [subsubblock, above right=of types] (pageeditormodel) {Page\\Editor Model};
        
        % Operations sub-module
        \node [subsubblock, above=of operations] (customrendering) {Custom\\Rendering};
        
        % Components sub-modules
        \node [subsubblock, below left=of components] (editorcomponents) {Editor\\Components};
        \node [subsubblock, below right=of components] (pageeditorcomponents) {Page\\Editor Components};
        
        % Draw arrows
        \foreach \i in {types,utilities,operations,components}
            \path [line] (editor) -- (\i);
        \path [line] (types) -- (editormodel);
        \path [line] (types) -- (pageeditormodel);
        \path [line] (operations) -- (customrendering);
        \path [line] (components) -- (editorcomponents);
        \path [line] (components) -- (pageeditorcomponents);
    \end{tikzpicture}
    \caption{Editor Module Structure}
    \label{fig:editor-module-structure}
\end{figure}



\section{Challenges and Solutions}

\section{Building and Deployment}

Now that we have described the implementation of the \emph{Data-driven UI} system, we must describe how the application is built and deployed. 
As we mentioned in Section~\ref{sec:technologies}, we use the \emph{Build} project provided by the \citet{safestack} template.
The original SAFE stack \emph{Build} project supports building \emph{full-stack} applications written in F\#, and we modified it to remove the support for building 
the \emph{Shared} and \emph{Server} projects, as our programming system only consists of a client-side application.

\subsection{Build Tools and Libraries}

The two main tools used by the \emph{Build} project are the following:
\begin{itemize}
 \item \textbf{FAKE (F\# Make):} A build automation tool for projects written in F\#, used to define build targets and their individual build steps.
  \item \textbf{Vite:} A web development tool for building JavaScript client-side applications, which provides a development server environment with Hot Module Replacement capability.
\end{itemize}

\subsection{Build targets}

The \emph{Build} project contains  targets:

\begin{itemize}
    \item \textbf{Development Server:} Configuration for running a local development server with HMR capabilities.
    \item \textbf{Asset Bundling:} Rules for bundling and optimizing our application assets, including JavaScript, CSS, and static files.
    \item \textbf{Testing:} Configuration for running our unit and integration tests.
    
\end{itemize}



\section{Testing}
To test our implementation, we created a separate project named \emph{Tests}.
We implemented \emph{Unit tests} for various operations from the Core Logic module, such as the \emph{replace} function from the \emph{CoreLogic.Operations.RenderingCode} module, and various functions from the \emph{CoreLogic.Operations.CodeGeneration} module.

We use the \citet{mocha} library which provides
\section{Summary}
