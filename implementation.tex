\chapter{Implementation}
\label{chap:implementation}

In this Chapter, we describe the practical realization of the design principles described in Chapter~\ref{chap:design} and the core logic described in Chapter~\ref{chap:corelogic}.
We explore the technologies chosen, the system's architecture, and key implementation details of \emph{Data-driven UI}.


\section{Technologies}
\label{sec:technologies}
To provide context for the implementation, we'll first examine the technologies used in developing the \emph{Data-driven UI} system, as our technological choices significantly shaped the design and functionality of the resulting application.

We decided to create the \emph{Data-driven UI} editor in a from of a browser-based client-side application providing a graphical user interface, rather than a traditional desktop application.
We made this decision to allow greater cross-platform compatibility and the ability to see the preview of the created web applications in a browser-based environment.
We also wanted to implement the system using a programming language with functional programming capabilities and a strong ecosystem, which narrowed our range of suitable options.
The system is implemented using the following key technologies:
\begin{itemize}
	\item \textbf{F\#:} The \citet{fsharp} programming language is used to implement the entire application, including the core logic and the user interface, chosen for its strong type system and functional programming capabilities.
	\item \textbf{Fable:} The \citet{fable} compiler, briefly described in Section~\ref{sub:Fable}, compiles the F\# source code to JavaScript, enabling browser-based execution and using technologies from the JavaScript ecosystem.
	\item \textbf{React:} The \citet{feliz} library provides a domain-specific language (DSL) for building \emph{React} user interface components and applications in F\#.
	\item \textbf{Elmish:} \citet{elmish} is a library used to enable the creation of Elmish style applications in F\#, which follow the MVU pattern described in Section~\ref{sub:elmish}.
	\item \textbf{Tailwind:} We use the \citet{tailwind} CSS framework for the layout and styling of the UI components of the application, which provides composable CSS classes and enables high customizability of the UI.
	\item \textbf{SimpleJson:} The \citet{simpleJson} library is used to parse the input JSON data into the internal representation described in Section~\ref{sub:json}.
\end{itemize}


\subsection{Alternatives}
While we selected the technologies mentioned in the previous Section for our implementation, several alternative options exist:
\begin{itemize}
	\item \textbf{Programming Language:} Instead of F\#, we could have used other functional programming languages such as Haskell or OCaml.
	      These languages also offer strong type systems and functional programming capabilities.
	      However, F\# was chosen for its seamless integration with the .NET ecosystem, high-quality development tools and documentation, and its ability to be compiled to JavaScript via Fable.

	\item \textbf{CSS Framework:} We considered using alternative CSS frameworks, such as Bulma or Bootstrap, which provide pre-made styled components.
	      We chose to use Tailwind instead, as the composable styling classes allow for a more direct approach to styling UI elements, instead of trying to adapt and modify the pre-made components.

	\item \textbf{JSON Parsing:} Instead of Fable.SimpleJson, we could have used the closest alternative library called \citet{thoth}.
	      The main strenght of this library is the ability to create custom JSON \emph{encoders} and \emph{decoders}.
	      However, as we need to be able to parse JSON data of abitrary strucuture, SimpleJson's lightweight nature and the way it represents the parsed data made it our preffered choice.
\end{itemize}
While these alternatives have their strengths, our chosen technologies provided the best balance of functional programming capabilities, browser compatibility, and ecosystem support for our specific requirements.


\section{System architecture}
\label{sec:appArch}
Before we describe the implementation specifics, we must first describe the \emph{architecture} and \emph{design} of the implementation.
Our main goal was to make the system extensible and maintainable.
The architecture was inspired by the \emph{Domain-driven} architecture.
The implementation consists of different F\# \emph{modules}, each providing different functionality.
We can divide the modules into two categories based on their roles as seen in Figure~\ref{fig:architecture}.
The two main categories are the following:
\begin{enumerate}
	\item \textbf{Core logic modules:} Modules implementing the Core logic described in Chapter~\ref{chap:corelogic}.
	\item \textbf{Editor modules:} Modules focused on implementing the user interface of the programming system and its functionality.
\end{enumerate}

Each module comprises various functions or type definitions.
In our implementation, we separate type definitions and functions into distinct modules, similarly to the separation of \emph{Domain} and \emph{Infrastructure} layers of the \emph{Domain-driven} architecture.
The modules containing the type definitions define the system's domain and have either none or a small number of external dependencies.
The modules containing the functions implement the behaviors and operations that manipulate and utilize the domain types.

\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[
			node distance = 1cm and 1.5cm,
			block/.style = {rectangle, draw, fill=blue!20,
					text width=6em, text centered, rounded corners, minimum height=3em},
			line/.style = {draw, -stealth},
		]
		% Main application node
		\node [block, text width=10em] (app) {Data-driven UI Application};

		% Module types
		\node [block, below left=of app] (core) {Core Logic Modules};
		\node [block, below=of app] (editor) {Editor Modules};

		% Draw arrows
		\path [line] (app) -- (core);
		\path [line] (app) -- (editor);


		% Add a border around the entire diagram
		\node [fit=(app) (core) (editor) , inner sep=0.5cm, draw] {};

	\end{tikzpicture}
	\caption{Types of Modules in the Data-driven UI Application}
	\label{fig:architecture}
\end{figure}



\section{Core logic}

The
\section{Editor}
\label{sec:ui}

\section{Utilities}


\section{Challenges and Solutions}

\section{Testing}

\section{Summary}
